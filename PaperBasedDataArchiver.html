<html>

	<head>
		<style>
			input[type=number]
			{
				width: 64px;
			}

			canvas
			{
				border: 1px solid;
			}
		</style>
	</head>

<body>

<div id="divUi">

	<h3>Paper-Based Data Archiver</h3>

	<p>
		Upload a file and click the Print button to see its data
		converted to a black-and-white image suitable for printing.
		(Eventually, it is planned to allow for converting
		a scanned image back to data, but this is not yet implemented.)
	</p>

	<div>
		<label>Data as Base64:</label>
		<button onclick="buttonDemo_Clicked()">Generate Random Data</button>
		<label>Load from File:</label>
		<input
			id="inputFileBytes"
			type="file"
			onchange="inputFileBytes_Changed(this)"
		/>
		<br />
		<textarea id="textareaDataAsBase64" cols="40" rows="10"></textarea>
	</div>

	<div>
		<label>Page:</label>

		<div>
			<label>Size in Inches:</label>
			<input id="inputPageSizeInInchesX" type="number" value="8.5"></input>
			<label>x</label>
			<input id="inputPageSizeInInchesY" type="number" value="11"></input>
		</div>

		<div>
			<label>Margin in Inches:</label>
			<input
				id="inputMarginInInchesX"
				type="number"
				value=".5"
			/>
			<label>x</label>
			<input
				id="inputMarginInInchesY"
				type="number"
				value="1"
			/>
		</div>

		<div>
			<label>Pixels per Inch:</label>
			<input
				id="inputPixelsPerInch"
				type="number"
				min="100" max="1200" step="1"
				value="100"
			></input>
		</div>

		<div>
			<label>Font:</label>
			<select id="selectFontName">
				<option selected="true">Courier New</option>
			</select>
			<label>Height in Pixels:</label>
			<input
				id="inputFontHeightInPixels"
				type="number"
				min="5" max="12" step="1"
				value="5"
			/>
		</div>

		<div>
			<button onclick="buttonBase64ToImage_Clicked()">v Base64 To Image v</button>
			<button onclick="buttonImageToBase64_Clicked()">^ Image to Base64 ^</button>
		</div>
	</div>

	<div>
		<label>Data as Image:</label>
		<input
			id="inputFileImage"
			type="file"
			onchange="inputFileImage_Changed(this)"
		/>
		<button onclick="buttonDrawCharacterGrid_Clicked()">Draw Character Grid as Overlay</button>
		<br />
		<div id="divImage">[none]</div>
	</div>

</div>

<script type="text/javascript">

function buttonBase64ToImage_Clicked()
{
	var d = document;

	var textareaDataAsBase64 =
		d.getElementById("textareaDataAsBase64");
	var dataAsBase64 = textareaDataAsBase64.value;
	var dataAsBytes = btoa(dataAsBase64);

	var page = Page.fromDocument(d);

	page.dataAsBytesSet(dataAsBytes);

	var pageAsCanvas = page.toCanvasForDocument(d);

	var divImage = d.getElementById("divImage");
	divImage.innerHTML = "";
	divImage.appendChild(pageAsCanvas);
}

function buttonDemo_Clicked()
{
	var d = document;

	var page = Page.fromDocument(d);

	var pageSizeInChars = page.sizeInChars();

	var charsInOrder = Base64.digitsInOrder();

	var linesSoFar = [];

	for (var y = 0; y < pageSizeInChars.y; y++)
	{
		var lineSoFar = "";

		for (var x = 0; x < pageSizeInChars.x; x++)
		{
			var charRandomIndex =
				Math.floor(charsInOrder.length * Math.random() );

			var charRandom = charsInOrder[charRandomIndex];

			lineSoFar += charRandom;
		}

		linesSoFar.push(lineSoFar);
	}

	var textareaDataAsBase64 =
		d.getElementById("textareaDataAsBase64");

	textareaDataAsBase64.value = linesSoFar.join("");
}

function buttonDrawCharacterGrid_Clicked()
{
	var d = document;
	var page = Page.fromDocument(d);
	page.characterGridDraw();
}

function buttonImageToBase64_Clicked()
{
	alert("Not yet implemented!");
}

function inputFileBytes_Changed(inputFileBytes)
{
	var file = inputFileBytes.files[0];
	if (file != null)
	{
		var fileReader = new FileReader();
		fileReader.onload = (event) =>
		{
			var fileAsBinaryString = event.target.result;
			var fileAsBytes =
				fileAsBinaryString
					.split("")
					.map(x => x.charCodeAt(0) );
			var fileAsBase64 = btoa(fileAsBytes);
			var d = document;
			var textareaDataAsBase64 =
				d.getElementById("textareaDataAsBase64");
			textareaDataAsBase64.value = fileAsBase64;
		}
		fileReader.readAsBinaryString(file);
	}
}

function inputFileImage_Changed(inputFileImage)
{
	var file = inputFileBytes.files[0];
	if (file != null)
	{
		var fileReader = new FileReader();
		fileReader.onload = (event) =>
		{
			var fileAsDataUrl = event.target.result;
			var d = document;
			var fileAsImgElement = d.createElement("img");
			fileAsImgElement.onload = (event2) =>
			{
				var fileAsCanvas = d.createElement("canvas");
				fileAsCanvas.width = fileAsImgElement.width;
				fileAsCanvas.height = fileAsImgElement.height;
				var graphics = fileAsCanvas.getContext("2d");
				graphics.drawImage(fileAsImgElement);

				var divImage =
					d.getElementById("divImage");
				divImage.innerHTML = "";
				divImage.appendChild(fileAsCanvas);
			}
			fileAsImgElement.src = fileAsDataUrl;
		}
		fileReader.readAsDataUrl(file);
	}

}

// Classes.

class Base64
{
	static digitsInOrder()
	{
		var charsInOrder =
			"0123456789"
			+ "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
			+ "abcdefghijklmnopqrstuvwxyz+/";

		return charsInOrder;
	}

	static digitsAsCanvas()
	{
		var d = document;
		var canvasForCharactersAvailable =
			d.createElement("canvas");
		var graphics = canvasForCharactersAvailable.getContext("2d");
		todo

	}

}

class Coords
{
	constructor(x, y)
	{
		this.x = x;
		this.y = y;
	}

	add(other)
	{
		this.x += other.x;
		this.y += other.y;
		return this;
	}

	addXY(x, y)
	{
		this.x += x;
		this.y += y;
		return this;
	}

	clone()
	{
		return new Coords(this.x, this.y);
	}

	divide(other)
	{
		this.x /= other.x;
		this.y /= other.y;
		return this;
	}

	floor()
	{
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	}

	multiply(other)
	{
		this.x *= other.x;
		this.y *= other.y;
		return this;
	}

	multiplyScalar(scalar)
	{
		this.x *= scalar;
		this.y *= scalar;
		return this;
	}

	overwriteWith(other)
	{
		this.x = other.x;
		this.y = other.y;
		return this;
	}

	subtract(other)
	{
		this.x -= other.x;
		this.y -= other.y;
		return this;
	}
}

class Font
{
	constructor(name, heightInPixels)
	{
		this.name = name;
		this.heightInPixels = heightInPixels;
	}

	toSystemFont()
	{
		return this.heightInPixels + "px " + this.name;
	}
}

class Page
{
	constructor
	(
		sizeInInches,
		marginInInches,
		pixelsPerInch,
		font,
		dataAsBytes,
		dataAsCanvas
	)
	{
		this.sizeInInches = sizeInInches;
		this.marginInInches = marginInInches;
		this.pixelsPerInch = pixelsPerInch;
		this.font = font;
		this.dataAsBytes = dataAsBytes;
		this.dataAsCanvas = dataAsCanvas;
	}

	static fromDocument(document)
	{
		var d = document;

		var pageSizeInInches = new Coords
		(
			parseFloat(d.getElementById("inputPageSizeInInchesX").value),
			parseFloat(d.getElementById("inputPageSizeInInchesY").value)
		);

		var marginSizeInInches = new Coords
		(
			parseFloat(d.getElementById("inputMarginInInchesX").value),
			parseFloat(d.getElementById("inputMarginInInchesY").value)
		);

		var pixelsPerInch =
			parseInt(d.getElementById("inputPixelsPerInch").value);

		var fontName =
			d.getElementById("selectFontName").value;

		var fontHeightInPixels =
			parseInt(d.getElementById("inputFontHeightInPixels").value);

		var font = new Font(fontName, fontHeightInPixels);

		var divImage = d.getElementById("divImage");
		var dataAsCanvas = divImage.children[0]; // Will be null at first.

		var page = new Page
		(
			pageSizeInInches,
			marginSizeInInches,
			pixelsPerInch,
			font,
			null, // dataAsBytes
			dataAsCanvas
		);

		return page;
	}

	characterGridDraw()
	{
		if (this.dataAsCanvas != null)
		{
			var d = document;
			var canvasForOverlay = d.createElement("canvas");
			canvasForOverlay.width = this.dataAsCanvas.width;
			canvasForOverlay.height = this.dataAsCanvas.height;

			var graphics = canvasForOverlay.getContext("2d");
			graphics.strokeStyle = "Cyan";

			var sizeInChars = this.sizeInChars();
			var charSizeInPixels = this.charSizeInPixels();
			var drawPosInChars = new Coords(0, 0);
			var drawPosInPixels = new Coords(0, 0);
			var marginSizeInPixels = this.marginInPixels();

			for (var y = 0; y < sizeInChars.y; y++)
			{
				drawPosInChars.y = y;

				for (var x = 0; x < sizeInChars.x; x++)
				{
					drawPosInChars.x = x;

					drawPosInPixels
						.overwriteWith(drawPosInChars)
						.multiply(charSizeInPixels)
						.add(marginSizeInPixels)
						.addXY(0, this.font.heightInPixels);

					graphics.strokeRect
					(
						drawPosInPixels.x, drawPosInPixels.y - charSizeInPixels.y,
						charSizeInPixels.x, charSizeInPixels.y
					);
				}
			}

			var graphics2 = this.dataAsCanvas.getContext("2d");
			graphics2.drawImage(canvasForOverlay, 0, 0);
		}

	}

	charSizeInPixels()
	{
		var d = document;
		var canvas = d.createElement("canvas");
		var graphics = canvas.getContext("2d");
		graphics.font = this.font.toSystemFont();
		var charMeasurement = graphics.measureText("M");
		var charSizeInPixels =
			new Coords(charMeasurement.width, this.font.heightInPixels);

		return charSizeInPixels;
	}

	dataAsBytesSet(values)
	{
		this.dataAsBytes = values;
		return this;
	}

	dataAsCanvasConvertToBytes()
	{
		// OCR.

		todo
	}

	dataAsBase64()
	{
		return atob(this.dataAsBytes);
	}

	marginInPixels()
	{
		var returnValue = this.marginInInches
			.clone()
			.multiplyScalar(this.pixelsPerInch);

		return returnValue;
	}

	sizeInChars()
	{
		var sizeInPixelsMinusMargins =
			this.sizeInPixelsMinusMargins();
		var charSizeInPixels = this.charSizeInPixels();
		var returnValue =
			sizeInPixelsMinusMargins
				.divide(charSizeInPixels)
				.floor();

		return returnValue;
	}

	sizeInInchesMinusMargins()
	{
		var returnValue =
			this.sizeInInches
				.clone()
				.subtract(this.marginInInches)
				.subtract(this.marginInInches);

		return returnValue;
	}

	sizeInPixels()
	{
		var returnValue =
			this.sizeInInches
				.clone()
				.multiplyScalar(this.pixelsPerInch);

		return returnValue;
	}

	sizeInPixelsMinusMargins()
	{
		var returnValue =
			this.sizeInInchesMinusMargins()
				.multiplyScalar(this.pixelsPerInch);

		return returnValue;
	}

	toCanvasForDocument(d)
	{
		var sizeInPixels = this.sizeInPixels();

		var canvas = d.createElement("canvas");
		canvas.width = sizeInPixels.x;
		canvas.height = sizeInPixels.y;

		var graphics = canvas.getContext("2d");
		graphics.fillStyle = "Black";
		graphics.font = this.font.toSystemFont();

		var dataAsBase64 = this.dataAsBase64();

		var dataAsLines = [];

		var sizeInChars = this.sizeInChars();
		var charSizeInPixels = this.charSizeInPixels();
		var drawPosInChars = new Coords(0, 0);
		var drawPosInPixels = new Coords(0, 0);
		var marginSizeInPixels = this.marginInPixels();

		for (var y = 0; y < sizeInChars.y; y++)
		{
			drawPosInChars.y = y;

			for (var x = 0; x < sizeInChars.x; x++)
			{
				drawPosInChars.x = x;

				drawPosInPixels
					.overwriteWith(drawPosInChars)
					.multiply(charSizeInPixels)
					.add(marginSizeInPixels)
					.addXY(0, this.font.heightInPixels);

				var charOffset = y * sizeInChars.x + x;

				var charToDraw = dataAsBase64[charOffset];

				graphics.fillText
				(
					charToDraw,
					drawPosInPixels.x, drawPosInPixels.y
				);
			}
		}

		this.dataAsCanvas = canvas;

		return this.dataAsCanvas;
	}
}

</script>

</body>

</html>